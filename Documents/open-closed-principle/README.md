# Принцип открытости-закрытости модуля

Одним из примеров принципа открытости-закрытости в языке C# может служит наследование абстрактного класса. 

Например, у нас есть абстрактный класс:
~~~C#
public abstract class Vehicle
    {
        public string Brand {get;set;}
        public Vehicle(string brand)
        {
            this.Brand = brand;
        }
        public abstract void Drive();
        public abstract void Reverse();
    }
~~~

Данный класс у нас **закрыт** для изменения, но мы можем расширить его функциональность, не внося изменений в него непосредственно. 

Для этого мы наследуемся от абстрактного класса и делаем свою реализацию с нужными нам изменениями:

~~~C#
public class Mercedes: Vehicle
    {
        public Mercedes(string brand):base(brand){}
        public override void Drive()
        {
            Console.WriteLine($"{Brand} is driving");
        }

        public override void Reverse()
        {
           Console.WriteLine($"{Brand} is reversing");
        }

        public void Drift()
        {
           Console.WriteLine($"{Brand} is drifting!");
        }
    }
~~~

Закрытость от изменений родительского класса `Vehicle` помогает нам создавать правильную архитектуру будущего приложения за счет упрощения последующей разработки посредством переиспользования основного функционала, а также задавать направление для проектирования иерархии классов.

Самый высокоуровневый пример в языке - класс `Object`, от которого наследуются все остальные классы. `Object` задает множество полезных методов, которые можно затем модифицировать в своих редакциях, например: `ToString()`, `GetHashCode` и другие.

Открытость, в свою очередь, позволяет нам, заложив основу закрытого класса через наследование, реализовать новый функционал, удовлетворяющий нашим требованиям.